===============================
IR to RF Remote Control Gateway
===============================

(c) 2016 David Banks

Introduction
============
This PIC project contains the IR to RF gateway that I use in my lounge
AV system. It allows RF remote controlled sockets to be controlled
from the IR signal generated by a Harmony Remote control.

Hardware
========

The PIC hardware, build on a bit of stripboard, includes:

- A PIC16F628 with a 4MHz crystal

- A IR receiver (from my junk box, so not sure what model exactly)
  connected to bit 4 of port A (pin 3)

- A 433.92 MHz RF transmitter (RT4) connected to bit 0 of port A (pin 17)

IR Protocol
===========

The PIC decodes the RC5 IR Protocol:
https://en.wikipedia.org/wiki/RC-5

This protocol uses a 5 bit command device address, and a 6 bit device command.

The PIC is programmed to respond to the following RC5 IR codes:

11001 - 000000 - Turn off device 0
11001 - 000001 - Turn off device 1
11001 - 000010 - Turn off device 2
11001 - 000011 - Turn off device 3
...
11001 - 001111 - Turn off device 15
11001 - 010000 - Turn on device 0
11001 - 010001 - Turn on device 1
11001 - 010010 - Turn on device 2
11001 - 010011 - Turn on device 3
..
11001 - 011111 - Turn on device 15

i.e. The device address is 0x19 (11001)

When mapping to Energenie RF, only 4 devices are supported.

RF Protocol
===========

The current version of this design works against the Energie MiHome
4-way RF controlled socket strip, sold by Screwfix in the UK in 2016.

On the RF side, the 433.92MHz Energenie protocol uses the following
encoding generted by the original Remote Control comprises:

A zero bit: 280us ON followed by 560us OFF (period 840us)

A one bit: 690us ON followed by 150us OFF (period 840us)

A post-amble bit: 180us on followed by 6560us OFF (perion 6840us).

It's the ON-OFF ratio that seems to matter rather than the bit
period, and the PIC currently uses a slightly longer period.

The RF code comprises 24 data bits followed by a postable bit,
and this sequence is repeated as long as the remote control button is
held down.

The 24 data bits are:
- 20 bit address, on my remote this was 0x1C0D8
-  4 bit command, see below

The commands are
-    Device 0 On        1111
-    Device 0 Off       1110
-    Device 1 On        0111
-    Device 1 Off       0110
-    Device 2 On        1011
-    Device 2 Off       1010
-    Device 3 On        0011
-    Device 3 Off       0010
- All devices On        1101
- All devices Off       1100

Training the Energie Socket
===========================

The Energenie socket can learn two seperate remote addresses, which I
was able to make use of:

- Remote address 1 was learnt from the original remote (which the PIC clones)
- Remote address 2 was learnt from a PiMote

The second remote address is useful because it allows a Raspberry Pi
(running Kodi) to switch itself off.

For more about the Energenie PiMote (ENER314), see:
https://energenie4u.co.uk/res/pdfs/ENER314%20UM.pdf

Older Version Notes
===================

The initial commit is an older version of the design that works with
the HomeEasy HE310 sockets that were sold by B&Q in the UK in 2010.

It also includes some additional functions (since disabled)

- A serial command interface, to allow a remote computer (in my case
  an tiny embedded 486). Command were ASCII, e.f. 13<cr> would turn on
  device 3, and 01<cr> would turn off device 1.

- An LED display connected to Port B bits 7,6,5,4,3 and 0. This was
  used for debugging, see code for details.

OpenElec Kodi Notes
===================

Initially I tried to have the IR remote power off Kodi at the right
time using fixed delays. But this was unreliable, as the amount of
time Kodi takes to shutdown is variable. So instead, I added a PiMote
to the Raspberry Pi, so it could switch it's self off in a shutdown
script.

It's possible that this shutdown is happening slightly too early, but
I haven't observed any corruption of the SD Card yet.

Some notes on how I setup OpenElec to activate the PiMote in a
shutdown script:

1. Added the "unofficial addon" repository addon

2. Installed RPi.GPIO Addon

3. Created a bash script /storage/.config/shutdown.sh:

#!/bin/bash
sync
sync
case "$1" in
  halt)
    # your commands here
    /storage/ENER314/shutdown.py
    ;;
  poweroff)
    # your commands here
    /storage/ENER314/shutdown.py
    ;;
  reboot)
    # your commands here
    ;;
  *)
    # your commands here
    ;;
esac

4. Created a python script: /storage/ENER314/shutdown.py

#!/usr/bin/python
#import the required modules
import sys
sys.path.append('/storage/.kodi/addons/python.RPi.GPIO/lib')
import RPi.GPIO as GPIO
import time

# set the pins numbering mode
GPIO.setmode(GPIO.BOARD)

# Select the GPIO pins used for the encoder K0-K3 data inputs
GPIO.setup(11, GPIO.OUT)
GPIO.setup(15, GPIO.OUT)
GPIO.setup(16, GPIO.OUT)
GPIO.setup(13, GPIO.OUT)

# Select the signal to select ASK/FSK
GPIO.setup(18, GPIO.OUT)

# Select the signal used to enable/disable the modulator
GPIO.setup(22, GPIO.OUT)

# Disable the modulator by setting CE pin lo
GPIO.output (22, False)

# Set the modulator to ASK for On Off Keying 
# by setting MODSEL pin lo
GPIO.output (18, False)

# Initialise K0-K3 inputs of the encoder to 0000
GPIO.output (11, False)
GPIO.output (15, False)
GPIO.output (16, False)
GPIO.output (13, False)

# Set K0-K3
GPIO.output (11, True)
GPIO.output (15, False)
GPIO.output (16, True)
GPIO.output (13, False)
# let it settle, encoder requires this
time.sleep(0.1)
# Enable the modulator
GPIO.output (22, True)
# keep enabled for a period
time.sleep(0.25)
# Disable the modulator
GPIO.output (22, False)

GPIO.cleanup()
